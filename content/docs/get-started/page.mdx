---
title: 'Intro'
---
## //get started

If you just want to get started using Nolita, you can run it using `npx`:

```
npx nolita
```

If you want to find out more about how it works, continue below.

### To start building a project

If you want to use Nolita to quickly bootstrap a full-stack agentic application, you can run the `create` command:

```
npx nolita create
```

After taking a name in, Nolita will create a sample project complete with information on tweaking each aspect of an agentic project.

### For quick tasks

You can run Nolita straight from the terminal to quickly accomplish an objective using a local sandboxed Chrome instance:

```
npx nolita [flags | config]
```

For the full configuration, see [our README](https://github.com/hdresearch/nolita?tab=readme-ov-file#running-quick-tasks).

### As a server for other projects

If you want to run Nolita as an objective-oriented browser automation engine -- that is, taking in a model, constructing an agent for you, and accomplishing a task on the internet -- you can do so by running Nolita as a server.

```
npx nolita serve [--port]
```

Basic documentation for the server is mounted at `http://localhost:port/doc`.

## //about nolita

Nolita is a full-stack agentic application framework intended for rapidly building projects from experiments to production.

At its core is a state-driven agentic architecture in concert with a browser automation engine. This allows for the creation of complex, dynamic, and interactive applications that can be run in a headless or headful mode in various contexts.

We provide the tools to bootstrap a complete full-stack agentic product that can navigate the web, get information and perform chains of tasks.

Nolita is written in TypeScript, but can serve as an objective-oriented browser automation framework for projects in other languages by running it as a server (see above).

When used to bootstrap a project, we include React and Express for the front-end and back-end logic. We leverage [Zod](https://github.com/colinhacks/zod) to coerce typed LLM output, which can be extended to enforce arbitrary typed responses as needed.

We wrote Nolita to be used best with our collective memory, which allows anyone to constrain the probability of agents and remember successful actions taken on similarly-structured sites in an abstracted format. By leveraging collective memory, powerful models aren&apos;t necessary to accomplish even complex and multi-step objectives across the web.

Using collective memory is not required to use Nolita, but Nolita works best when used together with our collective memory.